extends Node3D
@onready var 黑块场景 = preload("res://场景/音符/黑块.tscn")
@onready var 长块场景 = preload("res://场景/音符/长块.tscn")
@onready var 爆裂场景 = preload("res://场景/音符/爆裂.tscn")
@onready var 滑条场景 = preload("res://场景/音符/滑块.tscn")
@onready var 折叠滑条场景 = preload("res://场景/音符/折叠滑块.tscn")
@onready var 狂戳场景 = preload("res://场景/音符/狂戳.tscn")
@onready var 绿键场景 = preload("res://场景/音符/绿键.tscn")
@onready var 旋转场景 = preload("res://场景/音符/旋转.tscn")
@onready var 滑键场景 = preload("res://场景/音符/滑键.tscn")
@onready var 狂戳打击显示 = preload("res://场景/音符/狂戳打击显示.tscn")
@onready var 有轨轨道场景 = preload("res://场景/音符/有轨轨道.tscn")
@onready var 无轨轨道场景 = preload("res://场景/音符/无轨轨道.tscn")
@onready var 纹理=preload("res://纹理/界面/满星.svg")
##代码逻辑混乱，未来会考虑重构
#“0”为正式歌曲类型，“1”为旧式歌曲类型
var 歌曲类型格式:int=0
var 末尾音符:bool=true
var 无限模式:bool=false
var 自动模式:bool=false
var 歌曲循环次数:int=1
var 判定统计=[0,0,0,0,0,0]
var 生命值:float=100
var 游戏界面连击数:int = 0
var 最大连击数:int = 0
var 游戏界面分数:int = 0
var 物件连续:bool=false
#该变量用于确定物件的唯一编号
var 物件编号:int=0
#该变量用于确定物件的唯一编号
#var 轨道编号:int=0
#0代表空，1代表有方块，2代表伴奏块
var 物件位置占位:Array=[0,0,0,0]
#这个数组记录玩家打击的物件的精确度值
var 精确度判定组:Array=[]
#这个变量记载音频节点流的位置，所对应的当前json的星段位置
var 谱面阶段:int=0
var 音频延迟:float
var 对象文件声音数组:Dictionary={
	"C-4":0,
	"#C-4":1,
	"D-4":2,
	"#D-4":3,
	"E-4":4,
	"F-4":5,
	"#F-4":6,
	"G-4":7,
	"#G-4":8,
	"A-4":9,
	"#A-4":10,
	"B-4":11,
	"C-3":12,
	"#C-3":13,
	"D-3":14,
	"#D-3":15,
	"E-3":16,
	"F-3":17,
	"#F-3":18,
	"G-3":19,
	"#G-3":20,
	"A-3":21,
	"#A-3":22,
	"B-3":23,
	"C-2":24,
	"#C-2":25,
	"D-2":26,
	"#D-2":27,
	"E-2":28,
	"F-2":29,
	"#F-2":30,
	"G-2":31,
	"#G-2":32,
	"A-2":33,
	"#A-2":34,
	"B-2":35,
	"C-1":36,
	"#C-1":37,
	"D-1":38,
	"#D-1":39,
	"E-1":40,
	"F-1":41,
	"#F-1":42,
	"G-1":43,
	"#G-1":44,
	"A-1":45,
	"#A-1":46,
	"B-1":47,
	"c":48,
	"#c":49,
	"d":50,
	"#d":51,
	"e":52,
	"f":53,
	"#f":54,
	"g":55,
	"#g":56,
	"a":57,
	"#a":58,
	"b":59,
	"c1":60,
	"#c1":61,
	"d1":62,
	"#d1":63,
	"e1":64,
	"f1":65,
	"#f1":66,
	"g1":67,
	"#g1":68,
	"a1":69,
	"#a1":70,
	"b1":71,
	"c2":72,
	"#c2":73,
	"d2":74,
	"#d2":75,
	"e2":76,
	"f2":77,
	"#f2":78,
	"g2":79,
	"#g2":80,
	"a2":81,
	"#a2":82,
	"b2":83,
	"c3":84,
	"#c3":85,
	"d3":86,
	"#d3":87,
	"e3":88,
	"f3":89,
	"#f3":90,
	"g3":91,
	"#g3":92,
	"a3":93,
	"#a3":94,
	"b3":95,
	"c4":96,
	"#c4":97,
	"d4":98,
	"#d4":99,
	"e4":100,
	"f4":101,
	"#f4":102,
	"g4":103,
	"#g4":104,
	"a4":105,
	"#a4":106,
	"b4":107,
	"c5":108,
	"#c5":109,
	"d5":110,
	"#d5":111,
	"e5":112,
	"f5":113,
	"#f5":114,
	"g5":115,
	"#g5":116,
	"a5":117,
	"#a5":118,
	"b5":119,
	"c6":120,
	"#c6":121,
	"d6":122,
	"#d6":123,
	"e6":124,
	"f6":125,
	"#f6":126,
	"g6":127,
}
var 谱面段落时间差:float=0.0
#测试
var 轨道数量变更:int=0
#这个变量记载音频节点流的位置所对应的物件编号
var 物件摆放历史:int=0
var 玩法模式状态:bool=false
var 狂戳节奏模式:bool=false
var 精确度判定:float=0.0
var 声音数据集合:Array=[]
var 音符演奏方式:int=0
#MIDI乐谱定义
var 微秒每拍:int=60000000
var 每节节拍:int=4
var 物件生成微秒每拍:int=60000000
var 物件生成每节节拍:int=4
var 数码乐谱音色:Array=[]
var 数码文件指针:Array=[]
var 音符生成指针:Array=[]
var 数码乐谱播放时间:float=0.0
var 数码音符生成时间:float=0.0
var 数码文件通道状态:Array = []
func _ready():
	for 循环 in range( 16 ):
		var 鼓轨道:bool = ( 循环==9 )
		var 音色库:int = 0
		if 鼓轨道:
			音色库 = Bank.drum_track_bank
		self.数码文件通道状态.append( $'/root/根场景/视角节点/MidiPlayer'.GodotMIDIPlayerChannelStatus.new( 循环, 音色库, 鼓轨道 ) )
	pass
func _process(delta):
	#检测轨道数量的改变状态,如果改变则执行下列代码
	if 物件位置占位.size()!=轨道数量变更:
		轨道数量变更=物件位置占位.size()
		var 按键组=$'/root/根场景/根界面/设置/设置选项/控制'.有轨键盘按键布局.get(物件位置占位.size())
		var 手柄按键组=$'/root/根场景/根界面/设置/设置选项/控制'.有轨手柄按键布局.get(物件位置占位.size())
		#清空轨道所的绑定的按键
		for 循环 in $'轨道'.get_child_count():
			$'轨道'.get_child(循环).轨道编号=循环+1
			InputMap.action_erase_events(var_to_str(循环+1)+"轨道")
		#重新添加按键
		for 循环 in 物件位置占位.size():
			var 按键事件=InputEventKey.new()
			按键事件.keycode=按键组[循环]
			var 手柄按键事件=InputEventJoypadButton.new()
			手柄按键事件.button_index=手柄按键组[循环]
			InputMap.action_add_event(var_to_str(循环+1)+"轨道",按键事件)
			InputMap.action_add_event(var_to_str(循环+1)+"轨道",手柄按键事件)
			#(var_to_str(循环+1)+"轨道")
	#InputMap.add_action(var_to_str(KEY_D)+"按键")
	#InputMap.add_action(var_to_str(KEY_F)+"按键")
	#InputMap.add_action(var_to_str(KEY_J)+"按键")
	#InputMap.add_action(var_to_str(KEY_K)+"按键")
	#var 测试1=InputEventKey.new()
	#测试1.keycode=KEY_D
	#var 测试2=InputEventKey.new()
	#测试2.keycode=KEY_F
	#var 测试3=InputEventKey.new()
	#测试3.keycode=KEY_J
	#var 测试4=InputEventKey.new()
	#测试4.keycode=KEY_K
	#InputMap.action_add_event(var_to_str(KEY_D)+"按键",测试1)
	#InputMap.action_add_event(var_to_str(KEY_F)+"按键",测试2)
	#InputMap.action_add_event(var_to_str(KEY_J)+"按键",测试3)
	#InputMap.action_add_event(var_to_str(KEY_K)+"按键",测试4)
	物件连续=$'/root/根场景/根界面/游戏菜单/歌曲信息/歌曲信息/容器/物件连续/选项勾选盒'.button_pressed
	match 歌曲类型格式:
		0:
			if 全局脚本.游戏开始状态==true:
				if $'../视角节点/背景音乐播放节点'.playing==true:
					音频延迟=(1.5-(20*(4/物件生成每节节拍)*(-4.5))/(60000000.0/float(物件生成微秒每拍)))+全局脚本.音频延迟
					数码音符生成时间=(($'../视角节点/背景音乐播放节点'.播放时间+(谱面段落时间差/$'../视角节点/背景音乐播放节点'.get_pitch_scale()))*(1000000.0*全局脚本.数码乐谱文件数据.timebase))*$'../视角节点/背景音乐播放节点'.get_pitch_scale()/float(微秒每拍)
					数码乐谱播放时间=(($'../视角节点/背景音乐播放节点'.播放时间+((谱面段落时间差-音频延迟)/$'../视角节点/背景音乐播放节点'.get_pitch_scale()))*(1000000.0*全局脚本.数码乐谱文件数据.timebase))*$'../视角节点/背景音乐播放节点'.get_pitch_scale()/float(微秒每拍)
					#print(数码音符生成时间,",",数码乐谱播放时间,",",音频延迟)
					#数码乐谱播放时间+=float(全局脚本.数码乐谱文件数据.timebase) * delta * (1000000.0/(float(微秒每拍)) * $'../视角节点/背景音乐播放节点'.get_pitch_scale())
				#print(float(微秒每拍)/float(全局脚本.数码乐谱文件数据.timebase)/1000)
				for 轨道循环 in 全局脚本.数码乐谱文件数据.tracks.size():
					var 轨道 = 全局脚本.数码乐谱文件数据.tracks[轨道循环]
					if 轨道.events == null:
						return 0
					var 长度:int = len( 轨道.events )
					#物件生成
					while 音符生成指针[轨道循环] < 长度:
						var 事件块 = 轨道.events[音符生成指针[轨道循环]]
						if 数码音符生成时间<=float(事件块.time):
							break
						#(数码乐谱播放时间*(float(微秒每拍)/(1000000.0*全局脚本.数码乐谱文件数据.timebase)))-谱面段落时间差=$'../视角节点/背景音乐播放节点'.播放时间
						$'/root/根场景/根界面/游戏界面/游戏界面速度/每分钟节拍速'.text=var_to_str((60000000.0/float(微秒每拍))*$'../视角节点/背景音乐播放节点'.get_pitch_scale())
						$'/root/根场景/根界面/游戏界面/游戏界面速度/速度'.text="%.3f" %(((60000000.0/float(微秒每拍))/(240.0/float(每节节拍)))*$'../视角节点/背景音乐播放节点'.get_pitch_scale())
						音符生成指针[轨道循环] += 1
						var 事件 = 事件块.event
						match 事件.type:
							SMF.MIDIEventType.note_off:
								pass
								#await get_tree().create_timer(音频延迟).timeout
								#音符输入事件(事件.note,数码乐谱音色[轨道循环],事件.velocity,事件块.channel_number,MIDI_MESSAGE_NOTE_OFF)
							SMF.MIDIEventType.note_on:
								if 轨道循环==0:
									var 黑块=黑块场景.instantiate()
									黑块.position[1]=100.0
									黑块.数码乐谱节拍速度=(60000000.0/float(微秒每拍))
									黑块.数码乐谱基础节拍=(4.0/float(每节节拍))
									黑块.音符出现时间=$'../视角节点/背景音乐播放节点'.播放时间
									if $/root/根场景/根界面/游戏菜单/歌曲信息/歌曲信息/容器/无轨道模式/选项勾选盒.button_pressed==true:
										var 轨道位置=(randf()-0.5)*float(get_node("/root/根场景/根界面/游戏菜单/歌曲信息/歌曲信息/容器/轨道数量/滑块").value)*2-1
										黑块.position=Vector3(轨道位置,黑块.position[1],黑块.position[2])
										print("/root/根场景/主场景/无轨/无轨根节点"+var_to_str(轨道循环)+"/物件区")
										get_node("/root/根场景/主场景/无轨/无轨根节点"+var_to_str(轨道循环)+"/物件区").add_child(黑块)
									else:
										音符位置确定()
										音符生成(黑块,0)
										物件编号+=1
										黑块.物件编号=物件编号
										黑块.get_node("音符调试编号").text=var_to_str(物件编号)
										黑块.get_node("音符调试编号").show()
								#await get_tree().create_timer(音频延迟).timeout
								#音符输入事件(事件.note,数码乐谱音色[轨道循环],事件.velocity,事件块.channel_number,MIDI_MESSAGE_NOTE_ON)
							#控制器
							SMF.MIDIEventType.control_change:
								pass
							#弯音轮
							SMF.MIDIEventType.pitch_bend:
								pass
							#系统事件
							SMF.MIDIEventType.system_event:
								match 事件.args.type:
									#获取BPM的值
									SMF.MIDISystemEventType.set_tempo:
										#谱面段落时间差=((事件.args.bpm/(1000000*全局脚本.数码乐谱文件数据.timebase))*事件块.time)-((微秒每拍/(1000000*全局脚本.数码乐谱文件数据.timebase))*事件块.time)+谱面段落时间差
										#print((事件.args.bpm/(1000000*全局脚本.数码乐谱文件数据.timebase))*事件块.time)
										物件生成微秒每拍=事件.args.bpm
										#print(谱面段落时间差)
									#获取基础节拍
									SMF.MIDISystemEventType.beat:
										物件生成每节节拍=事件.args.beat32
					#音符播放
					while 数码文件指针[轨道循环] < 长度:
						var 事件块 = 轨道.events[数码文件指针[轨道循环]]
						if 数码乐谱播放时间<=float(事件块.time):
							break
						#(数码乐谱播放时间*(float(微秒每拍)/(1000000.0*全局脚本.数码乐谱文件数据.timebase)))-谱面段落时间差=$'../视角节点/背景音乐播放节点'.播放时间
						数码文件指针[轨道循环] += 1
						var 事件 = 事件块.event
						match 事件.type:
							SMF.MIDIEventType.note_off:
								match 全局脚本.数码乐谱文件数据.format_type:
									0:
										音符输入事件(事件.note,数码乐谱音色[事件块.channel_number],事件.velocity,事件块.channel_number,MIDI_MESSAGE_NOTE_OFF)
									1,2:
										音符输入事件(事件.note,数码乐谱音色[事件块.channel_number],事件.velocity,事件块.channel_number,MIDI_MESSAGE_NOTE_OFF)
										#音符输入事件(事件.note,数码乐谱音色[轨道循环],事件.velocity,事件块.channel_number,MIDI_MESSAGE_NOTE_OFF)
							SMF.MIDIEventType.note_on:
								match 全局脚本.数码乐谱文件数据.format_type:
									0:
										音符输入事件(事件.note,数码乐谱音色[事件块.channel_number],事件.velocity,事件块.channel_number,MIDI_MESSAGE_NOTE_ON)
									1,2:
										#if 轨道循环==0:
										#	print(事件块.channel_number)
										音符输入事件(事件.note,数码乐谱音色[事件块.channel_number],事件.velocity,事件块.channel_number,MIDI_MESSAGE_NOTE_ON)
										#音符输入事件(事件.note,数码乐谱音色[轨道循环],事件.velocity,事件块.channel_number,MIDI_MESSAGE_NOTE_ON)
							#控制器
							SMF.MIDIEventType.control_change:
								var 输入事件=InputEventMIDI.new()
								输入事件.message=MIDI_MESSAGE_CONTROL_CHANGE
								输入事件.channel=事件块.channel_number
								输入事件.controller_number=事件.number
								输入事件.controller_value=事件.value
								#await get_tree().create_timer(音频延迟).timeout
								$'/root/根场景/视角节点/MidiPlayer'.receive_raw_midi_message(输入事件)
							#音色改变
							SMF.MIDIEventType.program_change:
								match 全局脚本.数码乐谱文件数据.format_type:
									0:
										数码乐谱音色[事件块.channel_number]=事件.number
									1,2:
										数码乐谱音色[事件块.channel_number]=事件.number
										#数码乐谱音色[轨道循环]=事件.number
							#弯音轮
							SMF.MIDIEventType.pitch_bend:
								#print(事件.value)
								#await get_tree().create_timer(音频延迟).timeout
								音符输入事件(事件.value,0,0,事件块.channel_number,MIDI_MESSAGE_PITCH_BEND)
								pass
							#系统事件
							SMF.MIDIEventType.system_event:
								match 事件.args.type:
									#获取BPM的值
									SMF.MIDISystemEventType.set_tempo:
										谱面段落时间差=(数码乐谱播放时间*(float(事件.args.bpm)/(1000000.0*全局脚本.数码乐谱文件数据.timebase)))-(数码乐谱播放时间*(float(微秒每拍)/(1000000.0*全局脚本.数码乐谱文件数据.timebase)))+谱面段落时间差
										微秒每拍=事件.args.bpm
									#获取基础节拍
									SMF.MIDISystemEventType.beat:
										每节节拍=事件.args.beat32
									#时间码偏移
									SMF.MIDISystemEventType.smpte_offset:
										print(事件.args)
									#文本备注
									SMF.MIDISystemEventType.text_event:
										print(事件.args.text,"注释")
										pass
										#self.emit_signal( "appeared_text_event", event.args.text )
									#版权信息
									SMF.MIDISystemEventType.copyright:
										pass
										#self.emit_signal( "appeared_copyright", event.args.text )
									#音轨信息
									SMF.MIDISystemEventType.track_name:
										pass
										#self.emit_signal( "appeared_track_name", self._midi_channel_prefix, event.args.text )
										#self.channel_status[self._midi_channel_prefix].track_name = event.args.text
									#乐器名称
									SMF.MIDISystemEventType.instrument_name:
										pass
										#self.emit_signal( "appeared_instrument_name", self._midi_channel_prefix, event.args.text )
										#self.channel_status[self._midi_channel_prefix].instrument_name = event.args.text
									#歌词
									SMF.MIDISystemEventType.lyric:
										print(事件.args.text,"歌词")
										pass
										#self.emit_signal( "appeared_lyric", event.args.text )
									#标记
									SMF.MIDISystemEventType.marker:
										print(事件.args.text,"标记")
										pass
										#self.emit_signal( "appeared_marker", event.args.text )
									#提示点
									SMF.MIDISystemEventType.cue_point:
										print(事件.args.text,"提示点")
										pass
										#self.emit_signal( "appeared_cue_point", event.args.text )
									SMF.MIDISystemEventType.midi_channel_prefix:
										pass
										#self._midi_channel_prefix = event.args.channel
									SMF.MIDISystemEventType.sys_ex:
										pass
										#self._process_track_sys_ex( channel, event.args )
									SMF.MIDISystemEventType.divided_sys_ex:
										pass
										#self._process_track_sys_ex( channel, event.args )
								pass
			else:
				数码乐谱播放时间=0.0
		1:
			狂戳节奏模式=$"/root/根场景/根界面/游戏菜单/歌曲信息/歌曲信息/容器/狂戳块节奏模式/选项勾选盒".button_pressed
			#检测游戏状态
			if $"开始按键".visible==false && 全局脚本.游戏开始状态==true:
				$'/root/根场景/根界面/游戏界面/游戏界面血量条'.value=生命值
				#物件生成方式
				音频延迟=(1-(20*全局脚本.谱面基础节拍[谱面阶段]*(-4.5))/全局脚本.谱面每分钟节拍[谱面阶段])+全局脚本.音频延迟
				var 物件摆放:int=0
				#遍历音符数组
				for 循环 in 全局脚本.物件类型[0].size():
					if ((全局脚本.物件总时间[0][循环]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32)+谱面段落时间差<=$'../视角节点/背景音乐播放节点'.播放时间:
						if 循环==物件摆放历史+1:
							物件摆放=循环
							break
						#print(物件摆放历史)
					else:
						break
				if 谱面阶段<全局脚本.阶段时间位置.size()-1:
					if 全局脚本.阶段时间位置[谱面阶段+1]<=全局脚本.物件总时间[0][物件摆放]:
						var 星星贴图=$'/root/根场景/根界面/游戏界面/星星皇冠显示'.get_child(谱面阶段)
						星星贴图.set_texture(纹理)
						谱面段落时间差=(全局脚本.物件总时间[0][物件摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
						谱面阶段=谱面阶段+1
						玩法模式状态=false
				#	elif 全局脚本.阶段时间位置[谱面阶段]>=全局脚本.物件总时间[0][物件摆放]:
				#		谱面阶段=谱面阶段-1
				if $'../视角节点/背景音乐播放节点'.播放时间>=((全局脚本.物件总时间[0][物件摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32)+谱面段落时间差:
					if 物件摆放历史==物件摆放-1:
						var 物件:Node
						$'/root/根场景/根界面/游戏界面/游戏界面速度/每分钟节拍速'.text="%.2f" %(全局脚本.谱面每分钟节拍[谱面阶段]*$'../视角节点/背景音乐播放节点'.get_pitch_scale())
						$'/root/根场景/根界面/游戏界面/游戏界面速度/速度'.text="%.3f" %(float(全局脚本.谱面每分钟节拍[谱面阶段]/(全局脚本.谱面基础节拍[谱面阶段]*60))*$'../视角节点/背景音乐播放节点'.get_pitch_scale())
						#休止符替换
						if 全局脚本.物件类型[0][物件摆放]=="0":
							var 玩法模式时长=全局脚本.物件时长[0][物件摆放]
							for 轨道循环 in 全局脚本.物件类型.size()-1:
								if 全局脚本.物件类型[0][物件摆放]=="0":
									for 音符循环 in 全局脚本.物件类型[轨道循环+1].size():
										#判断伴奏的长度取值
										if 全局脚本.物件总时间[轨道循环+1][音符循环]>=全局脚本.物件总时间[0][物件摆放]&&全局脚本.物件总时间[轨道循环+1][音符循环]<全局脚本.物件总时间[0][物件摆放]+玩法模式时长:
											#检测伴奏音轨有实体音符
											if 全局脚本.物件类型[轨道循环+1][音符循环]!="0":
												if 玩法模式时长>32*全局脚本.谱面基础节拍[谱面阶段]:
													全局脚本.物件类型[0][物件摆放]="6>"
												else:
													全局脚本.物件类型[0][物件摆放]="1"
												break
								else:
									break
						if 玩法模式状态==false:
							#爆裂
							if 全局脚本.物件类型[0][物件摆放]=="10":
								物件=爆裂场景.instantiate()
								if 物件连续==false:
									if 物件位置占位.size()>=4:
										for 循环 in 物件位置占位.size():
											物件位置占位[循环]=0
										物件位置占位[((物件位置占位.size())/2)-1]=1
									else:
										音符位置确定()
								else:
									音符位置确定()
								if 物件位置占位.size()>1:
									if 物件位置占位[物件位置占位.size()-1]>=1:
										物件.position[0]=-1
									else:
										if (物件位置占位.size()%2)!=0&&物件连续==false:
											pass
										else:
											物件.position[0]=1
								var 通道=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[0])
								var 乐器=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[1])
								match 音符演奏方式:
									0:
										物件.音符序列=声音处理(全局脚本.对象文件乐谱声音[0][物件摆放],全局脚本.物件总时间[0][物件摆放],全局脚本.物件时长[0][物件摆放],通道,乐器,false)
									2:
										物件.音符序列=声音处理(全局脚本.对象文件乐谱声音[0][物件摆放],全局脚本.物件总时间[0][物件摆放],全局脚本.物件时长[0][物件摆放],通道,乐器,false)
										for 轨道循环 in 全局脚本.对象文件乐谱声音.size()-1:
											for 音符循环 in 全局脚本.对象文件乐谱声音[轨道循环+1].size():
												if 轨道循环>全局脚本.乐器音色[谱面阶段].size()-1:
													通道=0
													乐器=0
												else:
													通道=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[0])
													乐器=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[1])
												#判断长度取值
												if 全局脚本.物件总时间[轨道循环+1][音符循环]>=全局脚本.物件总时间[0][物件摆放]&&全局脚本.物件总时间[轨道循环+1][音符循环]<全局脚本.物件总时间[0][物件摆放]+全局脚本.物件时长[0][物件摆放]:
													物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[轨道循环+1][音符循环],全局脚本.物件总时间[轨道循环+1][音符循环],全局脚本.物件时长[轨道循环+1][音符循环],通道,乐器,false)
							#长块
							elif 全局脚本.物件类型[0][物件摆放].count('6')>0||全局脚本.物件类型[0][物件摆放].count('9')>0:
								物件=长块场景.instantiate()
								#单音符组方块
								if 全局脚本.物件类型[0][物件摆放].count('>') == 0:
									玩法模式状态=true
									var 玩法模式音符摆放=0
									var 玩法模式时长=全局脚本.物件时长[0][物件摆放]
									#检测音符类型并合并正确的音符时长
									while 全局脚本.物件类型[0][物件摆放+玩法模式音符摆放].count('>') == 0:
										玩法模式音符摆放=玩法模式音符摆放+1
										玩法模式时长=玩法模式时长+全局脚本.物件时长[0][物件摆放+玩法模式音符摆放]
										var 通道=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[0])
										var 乐器=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[1])
										match 音符演奏方式:
											0:
												物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件时长[0][物件摆放+玩法模式音符摆放-1],通道,乐器,false)
											2:
												物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件时长[0][物件摆放+玩法模式音符摆放-1],通道,乐器,false)
												for 轨道循环 in 全局脚本.对象文件乐谱声音.size()-1:
													for 音符循环 in 全局脚本.对象文件乐谱声音[轨道循环+1].size():
														if 轨道循环>全局脚本.乐器音色[谱面阶段].size()-1:
															通道=0
															乐器=0
														else:
															通道=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[0])
															乐器=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[1])
														#判断长度取值
														if 全局脚本.物件总时间[轨道循环+1][音符循环]>=全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1]&&全局脚本.物件总时间[轨道循环+1][音符循环]<全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1]+全局脚本.物件时长[0][物件摆放+玩法模式音符摆放-1]:
															物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[轨道循环+1][音符循环],全局脚本.物件总时间[轨道循环+1][音符循环],全局脚本.物件时长[轨道循环+1][音符循环],通道,乐器,false)
									物件.get_node("模型/长条尾").position=Vector3(0,(玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1)*3-1.5,0)
									物件.get_node("模型/长条腰").scale=Vector3(1,玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1,1)
									物件.get_node("模型/长条尾/标签").text="+"+var_to_str(int(玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)+1))
									物件.连击加分=int(玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0))
									物件.音符结束时间=(全局脚本.物件总时间[0][物件摆放]+玩法模式时长-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
									if 玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1>1:
										物件.get_node("模型/长条腰").show()
									if 全局脚本.物件类型[0][物件摆放].count('6')>0:
										音符位置确定()
									#伴奏块类型下添加子方块
									if 全局脚本.物件类型[0][物件摆放].count('9')>0:
										var 新位置占位:Array=[]
										var 伴奏生成范围:int=0
										#确认数组大小
										for 循环 in 物件位置占位.size():
											新位置占位.push_back(0)
										if 物件连续==false:
											if 物件位置占位.size()>=4:
												if 物件位置占位[0]==0:
													伴奏生成范围=0
													新位置占位[物件位置占位.size()-1]=1
												else:
													新位置占位[0]=1
													伴奏生成范围=2
												#print(新位置占位)
												物件位置占位=新位置占位
											else:
												音符位置确定()
										else:
											音符位置确定()
										for 轨道循环 in 全局脚本.物件类型.size()-1:
											for 音符循环 in 全局脚本.物件类型[轨道循环+1].size():
												#判断伴奏长块的长度取值
												if 全局脚本.物件总时间[轨道循环+1][音符循环]>=全局脚本.物件总时间[0][物件摆放]&&全局脚本.物件总时间[轨道循环+1][音符循环]<全局脚本.物件总时间[0][物件摆放]+玩法模式时长:
													if 物件连续==false:
														if 物件位置占位.size()>=4:
															var 子物件轨道数量=物件位置占位.size()-2
															var 轨道位置=int(floor(randf()*子物件轨道数量))
															while(新位置占位[轨道位置+伴奏生成范围]==2):
																if 轨道循环>=2:
																	break
																else:
																	轨道位置=int(floor(randf()*子物件轨道数量))
															for 循环 in 新位置占位.size():
																if 新位置占位[循环]==2:
																	新位置占位[循环]=0
															新位置占位[轨道位置+伴奏生成范围]=2
															物件位置占位=新位置占位
													else:
														if 物件位置占位.size()>=2:
															for 循环 in 新位置占位.size():
																if 物件位置占位[循环]==2:
																	物件位置占位[循环]=0
															var 轨道位置=int(floor(randf()*物件位置占位.size()))
															while(物件位置占位[轨道位置]==1||物件位置占位[轨道位置]==2):
																if 轨道循环+1>=物件位置占位.size():
																	break
																else:
																	轨道位置=int(floor(randf()*物件位置占位.size()))
															物件位置占位[轨道位置]=2
													#长块
													if 全局脚本.物件类型[轨道循环+1][音符循环].count('6')>0:
														var 子物件=长块场景.instantiate()
														子物件.position[1]=100.0
														子物件.get_node("模型/长条尾").position=Vector3(0,(全局脚本.物件时长[轨道循环+1][音符循环]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1)*3-1.5,0)
														子物件.get_node("模型/长条腰").scale=Vector3(1,全局脚本.物件时长[轨道循环+1][音符循环]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1,1)
														子物件.get_node("模型/长条尾/标签").text="+"+var_to_str(int(全局脚本.物件时长[轨道循环+1][音符循环]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)+1))
														子物件.连击加分=int(全局脚本.物件时长[轨道循环+1][音符循环]/(全局脚本.谱面基础节拍[谱面阶段]*32.0))
														if 全局脚本.物件时长[轨道循环+1][音符循环]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1>1:
															子物件.get_node("模型/长条腰").show()
														子物件.谱面阶段=谱面阶段
														子物件.音符出现时间=(全局脚本.物件总时间[轨道循环+1][音符循环]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
														子物件.音符结束时间=(全局脚本.物件总时间[轨道循环+1][音符循环]+ 全局脚本.物件时长[轨道循环+1][音符循环]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
														音符生成(子物件,轨道循环+1)
														物件编号+=1
														子物件.物件编号=物件编号
														子物件.get_node("音符调试编号").text=var_to_str(物件编号)
														子物件.get_node("音符调试编号").show()
													#其他类型一律按黑块处理
													else:
														var 子物件=黑块场景.instantiate()
														子物件.position[1]=100.0
														子物件.谱面阶段=谱面阶段
														子物件.音符出现时间=(全局脚本.物件总时间[轨道循环+1][音符循环]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
														音符生成(子物件,轨道循环+1)
														物件编号+=1
														子物件.物件编号=物件编号
														子物件.get_node("音符调试编号").text=var_to_str(物件编号)
														子物件.get_node("音符调试编号").show()
								else:
									玩法模式状态=false
									var 通道=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[0])
									var 乐器=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[1])
									match 音符演奏方式:
										0:
											物件.音符序列=声音处理(全局脚本.对象文件乐谱声音[0][物件摆放],全局脚本.物件总时间[0][物件摆放],全局脚本.物件时长[0][物件摆放],通道,乐器,false)
										2:
											物件.音符序列=声音处理(全局脚本.对象文件乐谱声音[0][物件摆放],全局脚本.物件总时间[0][物件摆放],全局脚本.物件时长[0][物件摆放],通道,乐器,false)
											for 轨道循环 in 全局脚本.对象文件乐谱声音.size()-1:
												for 音符循环 in 全局脚本.对象文件乐谱声音[轨道循环+1].size():
													if 轨道循环>全局脚本.乐器音色[谱面阶段].size()-1:
														通道=0
														乐器=0
													else:
														通道=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[0])
														乐器=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[1])
													#判断长度取值
													if 全局脚本.物件总时间[轨道循环+1][音符循环]>=全局脚本.物件总时间[0][物件摆放]&&全局脚本.物件总时间[轨道循环+1][音符循环]<全局脚本.物件总时间[0][物件摆放]+全局脚本.物件时长[0][物件摆放]:
														物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[轨道循环+1][音符循环],全局脚本.物件总时间[轨道循环+1][音符循环],全局脚本.物件时长[轨道循环+1][音符循环],通道,乐器,false)
													#长块
									#长条尾位置布局
									物件.get_node("模型/长条尾").position=Vector3(0,(全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1)*3-1.5,0)
									物件.get_node("模型/长条腰").scale=Vector3(1,全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1,1)
									物件.get_node("模型/长条尾/标签").text="+"+var_to_str(int(全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)+1))
									物件.连击加分=int(全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0))
									物件.音符结束时间=(全局脚本.物件总时间[0][物件摆放]+全局脚本.物件时长[0][物件摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
									if 全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1>1:
										物件.get_node("模型/长条腰").show()
									if 全局脚本.物件类型[0][物件摆放].count('6')>0:
										音符位置确定()
									#伴奏块类型下添加子方块
									if 全局脚本.物件类型[0][物件摆放].count('9')>0:
										var 新位置占位:Array=[]
										var 伴奏生成范围:int=0
										#确认数组大小
										for 循环 in 物件位置占位.size():
											新位置占位.push_back(0)
										if 物件连续==false:
											#如果轨道数为1时跳出死循环，不处理游戏会卡死!!!
											if 物件位置占位.size()>=4:
												if 物件位置占位[0]==1:
													伴奏生成范围=0
													新位置占位[物件位置占位.size()-1]=1
												else:
													新位置占位[0]=1
													伴奏生成范围=2
												物件位置占位=新位置占位
											else:
												音符位置确定()
										else:
											音符位置确定()
										for 轨道循环 in 全局脚本.物件类型.size()-1:
											for 音符循环 in 全局脚本.物件类型[轨道循环+1].size():
												#判断伴奏长块的长度取值
												if 全局脚本.物件总时间[轨道循环+1][音符循环]>=全局脚本.物件总时间[0][物件摆放]&&全局脚本.物件总时间[轨道循环+1][音符循环]<全局脚本.物件总时间[0][物件摆放]+全局脚本.物件时长[0][物件摆放]:
													if 物件连续==false:
														if 物件位置占位.size()>=4:
															var 子物件轨道数量=物件位置占位.size()-2
															var 轨道位置=int(floor(randf()*子物件轨道数量))
															while(新位置占位[轨道位置+伴奏生成范围]==2):
																if 轨道循环>=2:
																	break
																else:
																	轨道位置=int(floor(randf()*子物件轨道数量))
															for 循环 in 新位置占位.size():
																if 新位置占位[循环]==2:
																	新位置占位[循环]=0
															新位置占位[轨道位置+伴奏生成范围]=2
															物件位置占位=新位置占位
													else:
														if 物件位置占位.size()>=2:
															for 循环 in 新位置占位.size():
																if 物件位置占位[循环]==2:
																	物件位置占位[循环]=0
															var 轨道位置=int(floor(randf()*物件位置占位.size()))
															while(物件位置占位[轨道位置]==1||物件位置占位[轨道位置]==2):
																if 轨道循环+1>=物件位置占位.size():
																	break
																else:
																	轨道位置=int(floor(randf()*物件位置占位.size()))
															物件位置占位[轨道位置]=2
													#长块
													if 全局脚本.物件类型[轨道循环+1][音符循环].count('6')>0:
														var 子物件=长块场景.instantiate()
														子物件.position[1]=100.0
														子物件.get_node("模型/长条尾").position=Vector3(0,(全局脚本.物件时长[轨道循环+1][音符循环]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1)*3-1.5,0)
														子物件.get_node("模型/长条腰").scale=Vector3(1,全局脚本.物件时长[轨道循环+1][音符循环]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1,1)
														子物件.get_node("模型/长条尾/标签").text="+"+var_to_str(int(全局脚本.物件时长[轨道循环+1][音符循环]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)+1))
														子物件.连击加分=int(全局脚本.物件时长[轨道循环+1][音符循环]/(全局脚本.谱面基础节拍[谱面阶段]*32.0))
														if 全局脚本.物件时长[轨道循环+1][音符循环]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1>1:
															子物件.get_node("模型/长条腰").show()
														子物件.谱面阶段=谱面阶段
														子物件.音符出现时间=(全局脚本.物件总时间[轨道循环+1][音符循环]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
														子物件.音符结束时间=(全局脚本.物件总时间[轨道循环+1][音符循环]+全局脚本.物件时长[轨道循环+1][音符循环]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
														音符生成(子物件,轨道循环+1)
														物件编号+=1
														子物件.物件编号=物件编号
														子物件.get_node("音符调试编号").text=var_to_str(物件编号)
														子物件.get_node("音符调试编号").show()
													#其他类型一律按黑块处理
													else:
														var 子物件=黑块场景.instantiate()
														子物件.position[1]=100.0
														子物件.谱面阶段=谱面阶段
														子物件.音符出现时间=(全局脚本.物件总时间[轨道循环+1][音符循环]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
														音符生成(子物件,轨道循环+1)
														物件编号+=1
														子物件.物件编号=物件编号
														子物件.get_node("音符调试编号").text=var_to_str(物件编号)
														子物件.get_node("音符调试编号").show()
							#双押
							elif 全局脚本.物件类型[0][物件摆放].count('5')>0:
								var 新位置占位:Array=[]
								#确认数组大小
								for 循环 in 物件位置占位.size():
									新位置占位.push_back(0)
								if 物件连续==false:
									for 循环 in 物件位置占位.size():
										#如果轨道数为1时跳出死循环，不处理游戏会卡死!!!
										if 物件位置占位.size()==1:
											新位置占位[0]=1
											物件位置占位=新位置占位
											break
										else:
											if 物件位置占位[循环]==1:
												match 物件位置占位.size():
													2:
														if 循环==0:
															新位置占位[1]=1
														else:
															新位置占位[0]=1
													3:
														match 循环:
															0:
																新位置占位[2]=1
															1:
																if randf()>=0.5:
																	新位置占位[2]=1
																else:
																	新位置占位[0]=1
															2:
																新位置占位[0]=1
													_:
														if 循环-1<0:
															新位置占位[循环+1]=1
															新位置占位[循环+3]=1
														elif 循环+1>=物件位置占位.size():
															新位置占位[循环-1]=1
															新位置占位[循环-3]=1
														else:
															新位置占位[循环-1]=1
															新位置占位[循环+1]=1
												break
									#音符生成(物件,1)
									物件位置占位=新位置占位
								#打开连续生成状态
								else:
									if 物件位置占位.size()==1:
										新位置占位[0]=1
									else:
										var 轨道位置=int(floor(randf()*新位置占位.size()))
										新位置占位[轨道位置]=1
										#物件连续
										while(新位置占位[轨道位置]==1):
											轨道位置=int(floor(randf()*新位置占位.size()))
										新位置占位[轨道位置]=1
									物件位置占位=新位置占位
								if 全局脚本.物件类型[0][物件摆放].count('>') == 0:
									玩法模式状态=true
									var 玩法模式音符摆放=0
									var 玩法模式时长=全局脚本.物件时长[0][物件摆放]
									#判断物件类型
									while 全局脚本.物件类型[0][物件摆放+玩法模式音符摆放].count('>') == 0:
										玩法模式音符摆放=玩法模式音符摆放+1
										玩法模式时长=玩法模式时长+全局脚本.物件时长[0][物件摆放+玩法模式音符摆放]
									#检测是否为长块还是黑块
									if 玩法模式时长>32*全局脚本.谱面基础节拍[谱面阶段]:
										物件=长块场景.instantiate()
										物件.get_node("模型/长条尾").position=Vector3(0,(玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1)*3-1.5,0)
										物件.get_node("模型/长条腰").scale=Vector3(1,玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1,1)
										物件.get_node("模型/长条尾/标签").text="+"+var_to_str(int(玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)+1))
										物件.连击加分=int(玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0))
										物件.音符结束时间=(全局脚本.物件总时间[0][物件摆放]+玩法模式时长-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
										if 玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1>1:
											物件.get_node("模型/长条腰").show()
										var 子物件=长块场景.instantiate()
										子物件.position[1]=100.0
										子物件.get_node("模型/长条尾").position=Vector3(0,(玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1)*3-1.5,0)
										子物件.get_node("模型/长条腰").scale=Vector3(1,玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1,1)
										子物件.get_node("模型/长条尾/标签").text="+"+var_to_str(int(玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)+1))
										子物件.连击加分=int(玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0))
										if 玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1>1:
											子物件.get_node("模型/长条腰").show()
										子物件.谱面阶段=谱面阶段
										子物件.音符出现时间=(全局脚本.物件总时间[0][物件摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
										子物件.音符结束时间=(全局脚本.物件总时间[0][物件摆放]+玩法模式时长-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
										音符生成(子物件,1)
										物件编号+=1
										子物件.物件编号=物件编号
										子物件.get_node("音符调试编号").text=var_to_str(物件编号)
										子物件.get_node("音符调试编号").show()
									else:
										物件=黑块场景.instantiate()
										var 子物件=黑块场景.instantiate()
										子物件.position[1]=100.0
										子物件.谱面阶段=谱面阶段
										子物件.音符出现时间=(全局脚本.物件总时间[0][物件摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
										音符生成(子物件,1)
										物件编号+=1
										子物件.物件编号=物件编号
										子物件.get_node("音符调试编号").text=var_to_str(物件编号)
										子物件.get_node("音符调试编号").show()
									玩法模式音符摆放=0
									玩法模式时长=全局脚本.物件时长[0][物件摆放]
									#检测音符类型并合并正确的音符时长
									while 全局脚本.物件类型[0][物件摆放+玩法模式音符摆放].count('>') == 0:
										玩法模式音符摆放=玩法模式音符摆放+1
										玩法模式时长=玩法模式时长+全局脚本.物件时长[0][物件摆放+玩法模式音符摆放]
										var 通道=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[0])
										var 乐器=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[1])
										match 音符演奏方式:
											0:
												物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件时长[0][物件摆放+玩法模式音符摆放-1],通道,乐器,false)
											2:
												物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件时长[0][物件摆放+玩法模式音符摆放-1],通道,乐器,false)
												for 轨道循环 in 全局脚本.对象文件乐谱声音.size()-1:
													for 音符循环 in 全局脚本.对象文件乐谱声音[轨道循环+1].size():
														if 轨道循环>全局脚本.乐器音色[谱面阶段].size()-1:
															通道=0
															乐器=0
														else:
															通道=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[0])
															乐器=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[1])
														#判断长度取值
														if 全局脚本.物件总时间[轨道循环+1][音符循环]>=全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1]&&全局脚本.物件总时间[轨道循环+1][音符循环]<全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1]+全局脚本.物件时长[0][物件摆放+玩法模式音符摆放-1]:
															物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[轨道循环+1][音符循环],全局脚本.物件总时间[轨道循环+1][音符循环],全局脚本.物件时长[轨道循环+1][音符循环],通道,乐器,false)
								else:
									玩法模式状态=false
									if 全局脚本.物件时长[0][物件摆放]>32*全局脚本.谱面基础节拍[谱面阶段]:
										物件=长块场景.instantiate()
										#长条尾位置布局
										物件.get_node("模型/长条尾").position=Vector3(0,(全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1)*3-1.5,0)
										物件.get_node("模型/长条腰").scale=Vector3(1,全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1,1)
										物件.get_node("模型/长条尾/标签").text="+"+var_to_str(int(全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)+1))
										物件.连击加分=int(全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0))
										物件.音符结束时间=(全局脚本.物件总时间[0][物件摆放]+全局脚本.物件时长[0][物件摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
										if 全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1>1:
											物件.get_node("模型/长条腰").show()
										var 子物件=长块场景.instantiate()
										子物件.position[1]=100.0
										子物件.get_node("模型/长条尾").position=Vector3(0,(全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1)*3-1.5,0)
										子物件.get_node("模型/长条腰").scale=Vector3(1,全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1,1)
										子物件.get_node("模型/长条尾/标签").text="+"+var_to_str(int(全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)+1))
										子物件.连击加分=int(全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0))
										if 全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)-1>1:
											子物件.get_node("模型/长条腰").show()
										子物件.谱面阶段=谱面阶段
										子物件.音符出现时间=(全局脚本.物件总时间[0][物件摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
										子物件.音符结束时间=(全局脚本.物件总时间[0][物件摆放]+全局脚本.物件时长[0][物件摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
										音符生成(子物件,1)
										物件编号+=1
										子物件.物件编号=物件编号
										子物件.get_node("音符调试编号").text=var_to_str(物件编号)
										子物件.get_node("音符调试编号").show()
									else:
										物件=黑块场景.instantiate()
										var 子物件=黑块场景.instantiate()
										子物件.position[1]=100.0
										子物件.谱面阶段=谱面阶段
										子物件.音符出现时间=(全局脚本.物件总时间[0][物件摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
										音符生成(子物件,1)
										物件编号+=1
										子物件.物件编号=物件编号
										子物件.get_node("音符调试编号").text=var_to_str(物件编号)
										子物件.get_node("音符调试编号").show()
									var 通道=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[0])
									var 乐器=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[1])
									match 音符演奏方式:
										0:
											物件.音符序列=声音处理(全局脚本.对象文件乐谱声音[0][物件摆放],全局脚本.物件总时间[0][物件摆放],全局脚本.物件时长[0][物件摆放],通道,乐器,false)
										2:
											物件.音符序列=声音处理(全局脚本.对象文件乐谱声音[0][物件摆放],全局脚本.物件总时间[0][物件摆放],全局脚本.物件时长[0][物件摆放],通道,乐器,false)
											for 轨道循环 in 全局脚本.对象文件乐谱声音.size()-1:
												for 音符循环 in 全局脚本.对象文件乐谱声音[轨道循环+1].size():
													if 轨道循环>全局脚本.乐器音色[谱面阶段].size()-1:
														通道=0
														乐器=0
													else:
														通道=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[0])
														乐器=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[1])
													#判断长度取值
													if 全局脚本.物件总时间[轨道循环+1][音符循环]>=全局脚本.物件总时间[0][物件摆放]&&全局脚本.物件总时间[轨道循环+1][音符循环]<全局脚本.物件总时间[0][物件摆放]+全局脚本.物件时长[0][物件摆放]:
														物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[轨道循环+1][音符循环],全局脚本.物件总时间[轨道循环+1][音符循环],全局脚本.物件时长[轨道循环+1][音符循环],通道,乐器,false)
							#滑条
							elif 全局脚本.物件类型[0][物件摆放].count('7')>0||全局脚本.物件类型[0][物件摆放].count('8')>0:
								物件=滑条场景.instantiate()
								var 方向:int
								for 循环 in 物件位置占位.size():
									物件位置占位[循环]=0
								if randf()>=0.5:
									方向=1
									物件位置占位[0]=1
								else:
									方向=-1
									物件位置占位[物件位置占位.size()-1]=1
								#夹杂音符组的状态
								if 全局脚本.物件类型[0][物件摆放].count('>') == 0:
									玩法模式状态=true
									var 玩法模式音符摆放=0
									var 玩法模式时长=全局脚本.物件时长[0][物件摆放]
									#检测音符类型并合并正确的音符时长
									while 全局脚本.物件类型[0][物件摆放+玩法模式音符摆放].count('>') == 0:
										玩法模式音符摆放=玩法模式音符摆放+1
										玩法模式时长=玩法模式时长+全局脚本.物件时长[0][物件摆放+玩法模式音符摆放]
										var 通道=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[0])
										var 乐器=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[1])
										match 音符演奏方式:
											0:
												物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件时长[0][物件摆放+玩法模式音符摆放-1],通道,乐器,false)
											2:
												物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件时长[0][物件摆放+玩法模式音符摆放-1],通道,乐器,false)
												for 轨道循环 in 全局脚本.对象文件乐谱声音.size()-1:
													for 音符循环 in 全局脚本.对象文件乐谱声音[轨道循环+1].size():
														if 轨道循环>全局脚本.乐器音色[谱面阶段].size()-1:
															通道=0
															乐器=0
														else:
															通道=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[0])
															乐器=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[1])
														#判断长度取值
														if 全局脚本.物件总时间[轨道循环+1][音符循环]>=全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1]&&全局脚本.物件总时间[轨道循环+1][音符循环]<全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1]+全局脚本.物件时长[0][物件摆放+玩法模式音符摆放-1]:
															物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[轨道循环+1][音符循环],全局脚本.物件总时间[轨道循环+1][音符循环],全局脚本.物件时长[轨道循环+1][音符循环],通道,乐器,false)
									#折叠式滑块
									物件.get_node("标签").text="+"+var_to_str(int(玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)+1))
									物件.get_node("标签").position=Vector3(0,玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0)*3+1,0)
									if 全局脚本.物件类型[0][物件摆放].count('8')>0:
										#拆分滑块长度以计算需要添加多少个模型
										var 滑块长度拆分:float=float(玩法模式时长)/32.0
										if 滑块长度拆分>=1.0:
											物件.get_node("模型").basis[1]=Vector3(2*方向,1/(全局脚本.谱面基础节拍[谱面阶段]),0)
										else:
											物件.get_node("模型").basis[1]=Vector3(2*滑块长度拆分*方向,滑块长度拆分/(全局脚本.谱面基础节拍[谱面阶段]),0)
										for 循环 in int(滑块长度拆分):
											var 滑块模型=折叠滑条场景.instantiate()
											滑块模型.scale[1]=1/(全局脚本.谱面基础节拍[谱面阶段]);
											滑块模型.position[1]=6*(循环+1);
											滑块模型.position[0]=方向*(3+(pow(-1,循环)*3))
											if 滑块长度拆分-float(循环+1.0)>=1.0:
												滑块模型.basis[1]=Vector3(-2*方向*pow(-1,循环),1/(全局脚本.谱面基础节拍[谱面阶段]),0)
											else:
												滑块模型.basis[1]=Vector3(-2*(滑块长度拆分-float(循环+1))*方向*pow(-1,循环),(滑块长度拆分-float(循环+1))/(全局脚本.谱面基础节拍[谱面阶段]),0)
											物件.get_node("折叠滑条").add_child(滑块模型)
									#正常滑块
									else:
										物件.get_node("模型").scale[1]=玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0);
										物件.get_node("模型").basis[1]=Vector3(方向,玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0),0)
									
								#print(全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0))
								else:
									玩法模式状态=false
									物件.get_node("标签").text="+"+var_to_str(int(全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)+1))
									物件.get_node("标签").position=Vector3(方向*4,全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0)*3+1,0)
									var 通道=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[0])
									var 乐器=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[1])
									match 音符演奏方式:
										0:
											物件.音符序列=声音处理(全局脚本.对象文件乐谱声音[0][物件摆放],全局脚本.物件总时间[0][物件摆放],全局脚本.物件时长[0][物件摆放],通道,乐器,false)
										2:
											物件.音符序列=声音处理(全局脚本.对象文件乐谱声音[0][物件摆放],全局脚本.物件总时间[0][物件摆放],全局脚本.物件时长[0][物件摆放],通道,乐器,false)
											for 轨道循环 in 全局脚本.对象文件乐谱声音.size()-1:
												for 音符循环 in 全局脚本.对象文件乐谱声音[轨道循环+1].size():
													if 轨道循环>全局脚本.乐器音色[谱面阶段].size()-1:
														通道=0
														乐器=0
													else:
														通道=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[0])
														乐器=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[1])
													#判断长度取值
													if 全局脚本.物件总时间[轨道循环+1][音符循环]>=全局脚本.物件总时间[0][物件摆放]&&全局脚本.物件总时间[轨道循环+1][音符循环]<全局脚本.物件总时间[0][物件摆放]+全局脚本.物件时长[0][物件摆放]:
														物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[轨道循环+1][音符循环],全局脚本.物件总时间[轨道循环+1][音符循环],全局脚本.物件时长[轨道循环+1][音符循环],通道,乐器,false)
									if 全局脚本.物件类型[0][物件摆放].count('8')>0:
										var 滑块长度拆分:float=全局脚本.物件时长[0][物件摆放]/32
										if 滑块长度拆分>=1.0:
											物件.get_node("模型").basis[1]=Vector3(2*方向,1/(全局脚本.谱面基础节拍[谱面阶段]),0)
										else:
											物件.get_node("模型").basis[1]=Vector3(2*滑块长度拆分*方向,滑块长度拆分/(全局脚本.谱面基础节拍[谱面阶段]),0)
										for 循环 in int(滑块长度拆分)-1:
											var 滑块模型=折叠滑条场景.instantiate()
											滑块模型.scale[1]=1/(全局脚本.谱面基础节拍[谱面阶段]);
											滑块模型.position[1]=6*(循环+1);
											滑块模型.position[0]=方向*(3+(pow(-1,循环)*3))
											if 滑块长度拆分-float(循环+1.0)>=1.0:
												滑块模型.basis[1]=Vector3(-2*方向*pow(-1,循环),1/(全局脚本.谱面基础节拍[谱面阶段]),0)
											else:
												滑块模型.basis[1]=Vector3(-2*(滑块长度拆分-float(循环+1))*方向*pow(-1,循环),(滑块长度拆分-float(循环+1))/(全局脚本.谱面基础节拍[谱面阶段]),0)
											物件.get_node("折叠滑条").add_child(滑块模型)
									else:
										物件.get_node("模型").scale[1]=全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0);
										物件.get_node("模型").basis[1]=Vector3(方向,全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0),0)
							#狂戳
							elif 全局脚本.物件类型[0][物件摆放].count('3')>0:
								物件=狂戳场景.instantiate()
								if 物件连续==false:
									if 物件位置占位.size()>=4:
										for 循环 in 物件位置占位.size():
											物件位置占位[循环]=0
										物件位置占位[((物件位置占位.size())/2)-1]=1
									else:
										音符位置确定()
								else:
									音符位置确定()
								if 物件位置占位.size()>1:
									if 物件位置占位[物件位置占位.size()-1]>=1:
										物件.position[0]=-1
									else:
										if (物件位置占位.size()%2)!=0&&物件连续==false:
											pass
										else:
											物件.position[0]=1
								if 全局脚本.物件类型[0][物件摆放].count('>') == 0:
									玩法模式状态=true
									var 玩法模式音符摆放=0
									var 玩法模式时长=全局脚本.物件时长[0][物件摆放]
									#检测音符类型并合并正确的音符时长
									物件.狂戳轨道提示.push_back(((全局脚本.物件总时间[0][物件摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32)+谱面段落时间差)
									while 全局脚本.物件类型[0][物件摆放+玩法模式音符摆放].count('>') == 0:
										var 通道=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[0])
										var 乐器=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[1])
										match 音符演奏方式:
											0:
												物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件时长[0][物件摆放+玩法模式音符摆放-1],通道,乐器,false)
											2:
												物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1],全局脚本.物件时长[0][物件摆放+玩法模式音符摆放-1],通道,乐器,false)
												for 轨道循环 in 全局脚本.对象文件乐谱声音.size()-1:
													for 音符循环 in 全局脚本.对象文件乐谱声音[轨道循环+1].size():
														if 轨道循环>全局脚本.乐器音色[谱面阶段].size()-1:
															通道=0
															乐器=0
														else:
															通道=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[0])
															乐器=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[1])
														#判断长度取值
														if 全局脚本.物件总时间[轨道循环+1][音符循环]>=全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1]&&全局脚本.物件总时间[轨道循环+1][音符循环]<全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放-1]+全局脚本.物件时长[0][物件摆放+玩法模式音符摆放-1]:
															物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[轨道循环+1][音符循环],全局脚本.物件总时间[轨道循环+1][音符循环],全局脚本.物件时长[轨道循环+1][音符循环],通道,乐器,false)
										玩法模式音符摆放=玩法模式音符摆放+1
										玩法模式时长=玩法模式时长+全局脚本.物件时长[0][物件摆放+玩法模式音符摆放]
										物件.狂戳轨道提示.push_back(((全局脚本.物件总时间[0][物件摆放+玩法模式音符摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32)+谱面段落时间差)
									if 狂戳节奏模式==true:
										物件.get_node("模型/标签").text=var_to_str(玩法模式音符摆放)
										物件.狂戳叠加量=玩法模式音符摆放
										物件.狂戳节奏模式=狂戳节奏模式
									else:
										物件.get_node("模型/标签").text="x0"
										物件.狂戳节奏模式=狂戳节奏模式
									#物件.get_node("打击判定轨道").print_tree()
									#物件.get_node("模型").scale[1]=玩法模式时长/(全局脚本.谱面基础节拍[谱面阶段]*32.0);
								#print(全局脚本.物件时长[0][物件摆放]/(全局脚本.谱面基础节拍[谱面阶段]*32.0))
								else:
									玩法模式状态=false
									var 通道=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[0])
									var 乐器=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[1])
									match 音符演奏方式:
										0:
											物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[0][物件摆放],全局脚本.物件总时间[0][物件摆放],全局脚本.物件时长[0][物件摆放],通道,乐器,false)
									物件.狂戳轨道提示.push_back(((全局脚本.物件总时间[0][物件摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32)+谱面段落时间差)
									物件.get_node("模型/标签").hide()
									if 狂戳节奏模式==true:
										物件.get_node("模型/标签").text=""
										物件.狂戳叠加量=1
										物件.狂戳节奏模式=狂戳节奏模式
									else:
										物件.get_node("模型/标签").text="x0"
										物件.狂戳节奏模式=狂戳节奏模式
							#黑块
							elif 全局脚本.物件类型[0][物件摆放]!="0":
								物件=黑块场景.instantiate()
								音符位置确定()
								var 通道=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[0])
								var 乐器=int(全局脚本.乐器音色[谱面阶段][0].split(",", false)[1])
								match 音符演奏方式:
									0:
										物件.音符序列=声音处理(全局脚本.对象文件乐谱声音[0][物件摆放],全局脚本.物件总时间[0][物件摆放],全局脚本.物件时长[0][物件摆放],通道,乐器,false)
									2:
										物件.音符序列=声音处理(全局脚本.对象文件乐谱声音[0][物件摆放],全局脚本.物件总时间[0][物件摆放],全局脚本.物件时长[0][物件摆放],通道,乐器,false)
										for 轨道循环 in 全局脚本.对象文件乐谱声音.size()-1:
											for 音符循环 in 全局脚本.对象文件乐谱声音[轨道循环+1].size():
												if 轨道循环>全局脚本.乐器音色[谱面阶段].size()-1:
													通道=0
													乐器=0
												else:
													通道=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[0])
													乐器=int(全局脚本.乐器音色[谱面阶段][轨道循环].split(",", false)[1])
												#判断长度取值
												if 全局脚本.物件总时间[轨道循环+1][音符循环]>=全局脚本.物件总时间[0][物件摆放]&&全局脚本.物件总时间[轨道循环+1][音符循环]<全局脚本.物件总时间[0][物件摆放]+全局脚本.物件时长[0][物件摆放]:
													物件.音符序列=物件.音符序列+声音处理(全局脚本.对象文件乐谱声音[轨道循环+1][音符循环],全局脚本.物件总时间[轨道循环+1][音符循环],全局脚本.物件时长[轨道循环+1][音符循环],通道,乐器,false)
							if 全局脚本.物件类型[0][物件摆放]!="0":
								物件.谱面阶段=谱面阶段
								物件.position=Vector3(物件.position[0],100,物件.position[2])
								$'/root/根场景/根界面/游戏界面/游戏界面进度条'.value=(float(物件摆放)/float(全局脚本.物件总时间[0].size()))*100
								物件.音符出现时间=(全局脚本.物件总时间[0][物件摆放]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差
								if 物件摆放<全局脚本.物件总时间[0].size()-1:
										音符生成(物件,0)
										物件编号+=1
										物件.物件编号=物件编号
										物件.get_node("音符调试编号").text=var_to_str(物件编号)
										物件.get_node("音符调试编号").show()
								else:
									#该结果是检测歌曲结束之后的情况
									var 星星贴图=$'/root/根场景/根界面/游戏界面/星星皇冠显示'.get_child(谱面阶段)
									星星贴图.set_texture(纹理)
									if 末尾音符==true:
										末尾音符=false
										音符生成(物件,0)
										物件编号+=1
										物件.物件编号=物件编号
										物件.get_node("音符调试编号").text=var_to_str(物件编号)
										物件.get_node("音符调试编号").show()
						else:
							if 全局脚本.物件类型[0][物件摆放]=='>':
								玩法模式状态=false
						物件摆放历史=物件摆放
				if 全局脚本.挑战赛加速度[2]==true&&全局脚本.挑战赛加速度[0]!=0:
					var 真实时间=(Time.get_ticks_usec()-$'../视角节点/背景音乐播放节点'.真实播放时间)/1000000
					#var 实际时间=($'../视角节点/背景音乐播放节点'.pitch_scale-1)*($'../视角节点/背景音乐播放节点'.pitch_scale*(全局脚本.谱面每分钟节拍[0]/(60.0*全局脚本.谱面基础节拍[0])))/全局脚本.挑战赛加速度[0]
					$'../视角节点/背景音乐播放节点'.set_pitch_scale(真实时间*全局脚本.挑战赛加速度[0]/(全局脚本.谱面每分钟节拍[0]/(60.0*全局脚本.谱面基础节拍[0]))+1)
					#$'../视角节点/背景音乐播放节点'.set_pitch_scale(($'../视角节点/背景音乐播放节点'.播放时间*(1/$'../视角节点/背景音乐播放节点'.pitch_scale))*全局脚本.挑战赛加速度[0]/(全局脚本.谱面每分钟节拍[0]/(60.0*全局脚本.谱面基础节拍[0]))+1)
					#全局脚本.谱面每分钟节拍[谱面阶段]=(全局脚本.谱面基础节拍[谱面阶段]/全局脚本.谱面基础节拍[0])*(全局脚本.挑战赛加速度[1]+($'../视角节点/背景音乐播放节点'.播放时间*全局脚本.挑战赛加速度[0]*60*全局脚本.谱面基础节拍[0]))
			#检测歌曲播放是否结束？
			if 全局脚本.游戏开始状态==true:
				$'/root/根场景/根界面/游戏界面/自动演奏时间轴'.max_value=(全局脚本.物件总时间[0][全局脚本.物件总时间[0].size()-1]+全局脚本.物件时长[0][全局脚本.物件时长[0].size()-1]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差+音频延迟+1.0
				if $'../视角节点/背景音乐播放节点'.播放时间>=(全局脚本.物件总时间[0][全局脚本.物件总时间[0].size()-1]+全局脚本.物件时长[0][全局脚本.物件时长[0].size()-1]-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32+谱面段落时间差+音频延迟+1.0:
					$'../视角节点/背景音乐播放节点'.stop()
					#检测是否是无限模式
					if 无限模式==false:
						$'/root/根场景/根界面/游戏界面'.退出()
					else:
						$'/root/根场景/根界面/游戏界面/歌曲循环次数/文字'.text="循环"
						$'/root/根场景/根界面/游戏界面/歌曲循环次数/数值'.show()
						$'../视角节点/背景音乐播放节点'.seek(0)
						$'../视角节点/背景音乐播放节点'.播放时间=0.0
						$'../视角节点/背景音乐播放节点'.play()
						末尾音符=true
						玩法模式状态=false
						物件摆放历史=-1
						歌曲循环次数+=1
						物件编号=0
						$'/root/根场景/根界面/游戏界面/歌曲循环次数/数值'.text="x"+var_to_str(歌曲循环次数)
						if 全局脚本.挑战赛加速度[2]==false||全局脚本.挑战赛加速度[0]==0:
							$'../视角节点/背景音乐播放节点'.set_pitch_scale(1+(歌曲循环次数-1)*0.333)
						for 循环 in 声音数据集合.size():
							声音数据集合[循环].播放状态=0
			#下列循环在数组数量过多的时候导致卡顿，未来优化
			for 声音数据集合循环 in 声音数据集合.size():
				if ((声音数据集合[声音数据集合循环].出现时间-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32)+谱面段落时间差+音频延迟<=$'../视角节点/背景音乐播放节点'.播放时间:
					if 声音数据集合[声音数据集合循环].播放状态==0:
						声音数据集合[声音数据集合循环].播放状态=1
						var 半音=对象文件声音数组[声音数据集合[声音数据集合循环].声音]
						#print(半音)
						var 乐器=声音数据集合[声音数据集合循环].音色
						var 力度=100
						var 通道=声音数据集合[声音数据集合循环].通道
						var 状态=MIDI_MESSAGE_NOTE_ON
						音符输入事件(半音,乐器,力度,通道,状态)
						
				if (((声音数据集合[声音数据集合循环].出现时间+声音数据集合[声音数据集合循环].时长)-全局脚本.阶段时间位置[谱面阶段])*60/全局脚本.谱面每分钟节拍[谱面阶段]/32)+谱面段落时间差+音频延迟<=$'../视角节点/背景音乐播放节点'.播放时间:
					if 声音数据集合[声音数据集合循环].播放状态==1:
						声音数据集合[声音数据集合循环].播放状态=2
						var 半音休止=对象文件声音数组[声音数据集合[声音数据集合循环].声音]
						#print(半音)
						var 乐器休止=声音数据集合[声音数据集合循环].音色
						var 力度休止=100
						var 通道休止=声音数据集合[声音数据集合循环].通道
						var 状态休止=MIDI_MESSAGE_NOTE_OFF
						音符输入事件(半音休止,乐器休止,力度休止,通道休止,状态休止)
	pass
#开始游戏事件
func _input(事件):
	if 事件 is InputEventKey:
		$"开始按键/键盘提示文字".show()
		match 事件.keycode:
			KEY_SPACE:
				if $"开始按键".visible==true&&$'../根界面/加载画面'.visible==false&& not 事件.pressed:
					开始按钮()
		pass
	else:
		$"开始按键/键盘提示文字".hide()
	pass
func 清除物件():
	if $/root/根场景/根界面/游戏菜单/歌曲信息/歌曲信息/容器/无轨道模式/选项勾选盒.button_pressed==false:
		for 子节点循环 in $'/root/根场景/主场景/轨道'.get_child_count():
			var 子节点 = $'/root/根场景/主场景/轨道'.get_child(子节点循环)
			for 子节点二循环 in get_node('/root/根场景/主场景/轨道/'+子节点.name+'/物件区').get_child_count():
				var 物件区子节点=get_node('/root/根场景/主场景/轨道/'+子节点.name+'/物件区').get_child(子节点二循环)
				物件区子节点.queue_free()
		pass
	else:
		for 子节点循环 in $'/root/根场景/主场景/无轨'.get_child_count():
			var 子节点 = $'/root/根场景/主场景/无轨'.get_child(子节点循环)
			for 子节点二循环 in get_node('/root/根场景/主场景/无轨/'+子节点.name+'/物件区').get_child_count():
				var 物件区子节点=get_node('/root/根场景/主场景/无轨/'+子节点.name+'/物件区').get_child(子节点二循环)
				物件区子节点.queue_free()
		pass
func 音符输入事件(半音,乐器,力度,通道,状态)->void:
	var 输入事件=InputEventMIDI.new()
	输入事件.channel=通道
	输入事件.pitch=半音
	输入事件.velocity=力度
	输入事件.instrument=乐器
	输入事件.message=状态
	$'/root/根场景/视角节点/MidiPlayer'.receive_raw_midi_message(输入事件)
func 背景板装饰计时器():
	if 全局脚本.游戏开始状态==false&&全局脚本.调试状态==false:
		var 黑块:Node
		match randi() % 8:
			0:
				黑块=黑块场景.instantiate()
			1:
				黑块=长块场景.instantiate()
				var 长度缩放=randf()+1
				黑块.get_node("模型/长条尾").position=Vector3(0,(长度缩放)*3-1.5,0)
				黑块.get_node("模型/长条腰").scale=Vector3(1,长度缩放,1)
				黑块.get_node("模型/长条腰").show()
				黑块.get_node("模型/长条尾/标签").hide()
			2:
				黑块=狂戳场景.instantiate()
				黑块.get_node("模型/打击判定轨道").hide()
				黑块.get_node("模型/标签").hide()
				黑块.get_node("进度条").hide()
			3:
				黑块=滑条场景.instantiate()
				var 长度缩放=randf()+1
				黑块.get_node("模型").scale[1]=长度缩放;
				黑块.get_node("模型").basis[1]=Vector3((randf()-0.5)*2,长度缩放,0)
				黑块.get_node("标签").hide()
			4:
				黑块=爆裂场景.instantiate()
			5:
				黑块=绿键场景.instantiate()
			6:
				黑块=滑键场景.instantiate()
			7:
				黑块=旋转场景.instantiate()
		黑块.position=Vector3(0,40,0)
		音符位置确定()
		音符生成(黑块,0)
		#如果菜单界面严重掉帧，则尝试清除随机装饰物
		if Performance.get_monitor(Performance.TIME_FPS)<10.0:
			清除物件()
			
	pass # Replace with function body.
func 开始按钮():
	if $'/root/根场景/根界面/界面动画'.is_playing()==false:
		生命值=100.0
		物件编号=0
		$'/root/根场景/视角节点/背景音乐播放节点'.自动位置偏差=0.0
		if $'/root/根场景/根界面/游戏菜单/歌曲信息/歌曲信息/容器/无限模式/选项勾选盒'.button_pressed==true:
			无限模式=true
		else:
			无限模式=false
		if $'/root/根场景/根界面/游戏菜单/歌曲信息/歌曲信息/容器/自动演奏/选项勾选盒'.button_pressed==true:
			自动模式=true
		else:
			自动模式=false
		if 无限模式==true:
			$'/root/根场景/根界面/游戏界面/歌曲循环次数'.show()
			$'/root/根场景/根界面/游戏界面/歌曲循环次数/文字'.text="无限模式"
			$'/root/根场景/根界面/游戏界面/歌曲循环次数/数值'.hide()
		else:
			$'/root/根场景/根界面/游戏界面/歌曲循环次数'.hide()
		$/root/根场景/根界面/游戏界面/界面动画.play("标题关闭")
		#检测歌曲是否存在音频文件
		if $'../视角节点/背景音乐播放节点'.stream.to_string().find('MP3')>=0||$'../视角节点/背景音乐播放节点'.stream.to_string().find('WAV')>=0||$'../视角节点/背景音乐播放节点'.stream.to_string().find('Ogg')>=0:
			$'../视角节点/背景音乐播放节点'.播放时间=0.0
			$开始按键/背景音乐计时器.start()
		else:
			$'../视角节点/背景音乐播放节点'.play()
			$'../视角节点/背景音乐播放节点'.set_pitch_scale(1)
		$"开始按键".hide()
		精确度判定=0.0
		歌曲循环次数=1
		精确度判定组=[]
		谱面段落时间差=0.0
		$/root/根场景/根界面/游戏界面/游戏界面精确度.text="%02.2f" %floor(精确度判定)+"%"
		$'../视角节点/背景音乐播放节点'.真实播放时间=Time.get_ticks_usec()
		match 歌曲类型格式:
			0:
				音频延迟=0.0
				数码乐谱播放时间=0.0
				数码音符生成时间=0.0
				数码文件指针=[]
				音符生成指针=[]
				数码乐谱音色=[]
				for 循环 in 全局脚本.数码乐谱文件数据.tracks.size():
					数码文件指针.push_back(0)
					音符生成指针.push_back(0)
				#MIDI文件格式
				match 全局脚本.数码乐谱文件数据.format_type:
					0:
						#16为通道数量
						for 循环 in 16:
							数码乐谱音色.push_back(0)
					1,2:
						for 循环 in 全局脚本.数码乐谱文件数据.tracks.size():
							数码乐谱音色.push_back(0)
				for 轨道布置 in 全局脚本.数码乐谱文件数据.tracks.size()-2:
					if $/root/根场景/主场景/无轨.has_node("无轨根节点"+var_to_str(轨道布置+2))==false:
						var 无轨轨道=无轨轨道场景.instantiate()
						无轨轨道.name="无轨根节点"+var_to_str(轨道布置+2)
						无轨轨道.position=Vector3(0,(轨道布置+1)*4,(轨道布置+1)*4)
						无轨轨道.允许失误=false
						$/root/根场景/主场景/无轨.add_child(无轨轨道)
				if $/root/根场景/主场景/无轨.has_node("无轨根节点0")==false:
						var 无轨轨道=无轨轨道场景.instantiate()
						无轨轨道.name="无轨根节点0"
						无轨轨道.position=Vector3(0,-4,-4)
						无轨轨道.允许失误=false
						$/root/根场景/主场景/无轨.add_child(无轨轨道)
			1:
				末尾音符=true
				玩法模式状态=false
				谱面阶段=0
				物件摆放历史=-1
				声音数据集合=[]
				#预处理音符
				声音数据集合=[]
				match 音符演奏方式:
					1:
						for 音符轨道循环 in 全局脚本.物件总时间.size():#音轨遍历循环
							var 通道:int
							var 乐器:int
							if 音符轨道循环>全局脚本.乐器音色[0].size()-1:
								通道=0
								乐器=0
							else:
								通道=int(全局脚本.乐器音色[0][音符轨道循环].split(",", false)[0])
								乐器=int(全局脚本.乐器音色[0][音符轨道循环].split(",", false)[1])
							for 循环 in 全局脚本.物件总时间[音符轨道循环].size():#音轨内的音符遍历循环
								声音处理(全局脚本.对象文件乐谱声音[音符轨道循环][循环],全局脚本.物件总时间[音符轨道循环][循环],全局脚本.物件时长[音符轨道循环][循环],通道,乐器,true)
					2:
						pass
					0,_:
						for 音符轨道循环 in 全局脚本.物件总时间.size()-1:#音轨遍历循环
							var 通道:int
							var 乐器:int
							if 音符轨道循环>全局脚本.乐器音色[0].size()-2:
								通道=0
								乐器=0
							else:
								通道=int(全局脚本.乐器音色[0][音符轨道循环+1].split(",", false)[0])
								乐器=int(全局脚本.乐器音色[0][音符轨道循环+1].split(",", false)[1])
							for 循环 in 全局脚本.物件总时间[音符轨道循环+1].size():#音轨内的音符遍历循环
								声音处理(全局脚本.对象文件乐谱声音[音符轨道循环+1][循环],全局脚本.物件总时间[音符轨道循环+1][循环],全局脚本.物件时长[音符轨道循环+1][循环],通道,乐器,true)
				#print(声音数据集合)
			
func 开始按钮点击事件(摄像机, 事件, 触摸点位置, 法向量, 形状):
	if 事件 is InputEventScreenTouch:
		if 事件.pressed == true:
			开始按钮()
	pass # Replace with function body.
func 声音处理(判断条件,初始时间,时长,通道,音色,演奏状态:bool):
	#print(判断条件)
	#print(初始时间)
	#print(时长)
	var 音符序列=[]
	if 判断条件!="空白":
		判断条件=判断条件.replace("&","^")
		判断条件=判断条件.replace("&","~")
		#处理连音
		if 判断条件.count('~') > 0:
			var 数组=判断条件.split("~", false)
			for 循环 in 数组.size():
				#替换杂乱的功能字符
				数组[循环]=数组[循环].replace("@",".")
				数组[循环]=数组[循环].replace("!",".")
				数组[循环]=数组[循环].replace("%",".")
				数组[循环]=数组[循环].replace("^",".")
				var 音符出现时间=初始时间+(时长/数组.size()*循环)
				var 声音数据={"声音":"","出现时间":"","时长":"","通道":"","音色":""}
				声音数据.出现时间=音符出现时间
				声音数据.时长=时长
				声音数据.通道=通道
				声音数据.音色=音色
				声音数据.播放状态=0
				if 数组[循环].count('.') > 0:
					var 和弦数组=数组[循环].split(".", false)
					for 数组二循环 in 和弦数组.size():
						if 对象文件声音数组.has(和弦数组[数组二循环]):
							var 声音数据和弦={"声音":"","出现时间":"","时长":"","通道":"","音色":""}
							声音数据和弦.出现时间=音符出现时间
							声音数据和弦.时长=时长
							声音数据和弦.通道=通道
							声音数据和弦.音色=音色
							声音数据和弦.播放状态=0
							声音数据和弦.声音=和弦数组[数组二循环]
							if 演奏状态==true:
								声音数据集合.push_back(声音数据和弦)
							else:
								音符序列.push_back(声音数据和弦)
				else:
					if 对象文件声音数组.has(数组[循环]):
						声音数据.声音=数组[循环]
						if 演奏状态==true:
							声音数据集合.push_back(声音数据)
						else:
							音符序列.push_back(声音数据)
		#二分连音
		elif 判断条件.count('@') > 0:
			var 数组=判断条件.split("@", false)
			for 循环 in 数组.size():
				#替换杂乱的功能字符
				数组[循环]=数组[循环].replace("!",".")
				数组[循环]=数组[循环].replace("%",".")
				数组[循环]=数组[循环].replace("^",".")
				var 音符出现时间=(初始时间+(时长*0.1/数组.size()*循环))
				var 声音数据={"声音":"","出现时间":"","时长":"","通道":"","音色":""}
				声音数据.出现时间=音符出现时间
				声音数据.时长=时长
				声音数据.通道=通道
				声音数据.音色=音色
				声音数据.播放状态=0
				if 数组[循环].count('.') > 0:
					var 和弦数组=数组[循环].split(".", false)
					for 数组二循环 in 和弦数组.size():
						if 对象文件声音数组.has(和弦数组[数组二循环]):
							var 声音数据和弦={"声音":"","出现时间":"","时长":"","通道":"","音色":""}
							声音数据和弦.出现时间=音符出现时间
							声音数据和弦.时长=时长
							声音数据和弦.通道=通道
							声音数据和弦.音色=音色
							声音数据和弦.播放状态=0
							声音数据和弦.声音=和弦数组[数组二循环]
							if 演奏状态==true:
								声音数据集合.push_back(声音数据和弦)
							else:
								音符序列.push_back(声音数据和弦)
				else:
					if 对象文件声音数组.has(数组[循环]):
						声音数据.声音=数组[循环]
						if 演奏状态==true:
							声音数据集合.push_back(声音数据)
						else:
							音符序列.push_back(声音数据)
		#三分连音（琵音）
		elif 判断条件.count('!') > 0:
			var 数组=判断条件.split("!", false)
			for 循环 in 数组.size():
				#替换杂乱的功能字符
				数组[循环]=数组[循环].replace("%",".")
				数组[循环]=数组[循环].replace("^",".")
				var 音符出现时间=(初始时间+(时长*0.15/数组.size()*循环))
				var 声音数据={"声音":"","出现时间":"","时长":"","通道":"","音色":""}
				声音数据.出现时间=音符出现时间
				声音数据.时长=时长
				声音数据.通道=通道
				声音数据.音色=音色
				声音数据.播放状态=0
				if 数组[循环].count('.') > 0:
					var 和弦数组=数组[循环].split(".", false)
					for 数组二循环 in 和弦数组.size():
						if 对象文件声音数组.has(和弦数组[数组二循环]):
							var 声音数据和弦={"声音":"","出现时间":"","时长":"","通道":"","音色":""}
							声音数据和弦.出现时间=音符出现时间
							声音数据和弦.时长=时长
							声音数据和弦.通道=通道
							声音数据和弦.音色=音色
							声音数据和弦.播放状态=0
							声音数据和弦.声音=和弦数组[数组二循环]
							if 演奏状态==true:
								声音数据集合.push_back(声音数据和弦)
							else:
								音符序列.push_back(声音数据和弦)
				else:
					if 对象文件声音数组.has(数组[循环]):
						声音数据.声音=数组[循环]
						if 演奏状态==true:
							声音数据集合.push_back(声音数据)
						else:
							音符序列.push_back(声音数据)
		#四分连音（琵音）
		elif 判断条件.count('%') > 0:
			var 数组=判断条件.split("%", false)
			for 循环 in 数组.size():
				#替换杂乱的功能字符
				数组[循环]=数组[循环].replace("^",".")
				var 音符出现时间=(初始时间+(时长*0.3/数组.size()*循环))
				var 声音数据={"声音":"","出现时间":"","时长":"","通道":"","音色":""}
				声音数据.出现时间=音符出现时间
				声音数据.时长=时长
				声音数据.通道=通道
				声音数据.音色=音色
				声音数据.播放状态=0
				if 数组[循环].count('.') > 0:
					var 和弦数组=数组[循环].split(".", false)
					for 数组二循环 in 和弦数组.size():
						if 对象文件声音数组.has(和弦数组[数组二循环]):
							var 声音数据和弦={"声音":"","出现时间":"","时长":"","通道":"","音色":""}
							声音数据和弦.出现时间=音符出现时间
							声音数据和弦.时长=时长
							声音数据和弦.通道=通道
							声音数据和弦.音色=音色
							声音数据和弦.播放状态=0
							声音数据和弦.声音=和弦数组[数组二循环]
							if 演奏状态==true:
								声音数据集合.push_back(声音数据和弦)
							else:
								音符序列.push_back(声音数据和弦)
				else:
					if 对象文件声音数组.has(数组[循环]):
						声音数据.声音=数组[循环]
						if 演奏状态==true:
							声音数据集合.push_back(声音数据)
						else:
							音符序列.push_back(声音数据)
		#颤音
		elif 判断条件.count('^') > 0:
			var 数组=判断条件.split("^", false)
			数组=数组+数组+数组
			for 循环 in 数组.size():
				var 音符出现时间=初始时间+(时长/数组.size()*循环)
				var 声音数据={"声音":"","出现时间":"","时长":"","通道":"","音色":""}
				声音数据.出现时间=音符出现时间
				声音数据.时长=时长
				声音数据.通道=通道
				声音数据.音色=音色
				声音数据.播放状态=0
				if 数组[循环].count('.') > 0:
					var 和弦数组=数组[循环].split(".", false)
					for 数组二循环 in 和弦数组.size():
						if 对象文件声音数组.has(和弦数组[数组二循环]):
							var 声音数据和弦={"声音":"","出现时间":"","时长":"","通道":"","音色":""}
							声音数据和弦.出现时间=音符出现时间
							声音数据和弦.时长=时长
							声音数据和弦.通道=通道
							声音数据和弦.音色=音色
							声音数据和弦.播放状态=0
							声音数据和弦.声音=和弦数组[数组二循环]
							if 演奏状态==true:
								声音数据集合.push_back(声音数据和弦)
							else:
								音符序列.push_back(声音数据和弦)
				else:
					if 对象文件声音数组.has(数组[循环]):
						声音数据.声音=数组[循环]
						if 演奏状态==true:
							声音数据集合.push_back(声音数据)
						else:
							音符序列.push_back(声音数据)
		elif 判断条件.count('.') > 0:
			var 数组=判断条件.split(".", false)
			for 循环 in 数组.size():
				var 音符出现时间=初始时间
				var 声音数据={"声音":"","出现时间":"","时长":"","通道":"","音色":""}
				声音数据.出现时间=音符出现时间
				声音数据.时长=时长
				声音数据.通道=通道
				声音数据.音色=音色
				声音数据.播放状态=0
				if 对象文件声音数组.has(数组[循环]):
					声音数据.声音=数组[循环]
					if 演奏状态==true:
						声音数据集合.push_back(声音数据)
					else:
						音符序列.push_back(声音数据)
		else:
			var 声音数据={"声音":"","出现时间":"","时长":"","通道":"","音色":""}
			声音数据.出现时间=初始时间
			声音数据.时长=时长
			声音数据.通道=通道
			声音数据.音色=音色
			声音数据.播放状态=0
			if 对象文件声音数组.has(判断条件):
				声音数据.声音=判断条件
				if 演奏状态==true:
					声音数据集合.push_back(声音数据)
				else:
					音符序列.push_back(声音数据)
	return 音符序列
func 音符位置确定():
	var 新位置占位:Array=[]
	#确认数组大小
	for 循环 in 物件位置占位.size():
		新位置占位.push_back(0)
	var 轨道位置=int(floor(randf()*物件位置占位.size()))
	if 物件连续==false:
		#物件连续
		while(物件位置占位[轨道位置]==1):
			#如果轨道数为1时跳出死循环，不处理游戏会卡死!!!
			if 物件位置占位.size()==1:
				新位置占位[0]=1
				物件位置占位=新位置占位
				break
			else:
				轨道位置=int(floor(randf()*物件位置占位.size()))
		新位置占位[轨道位置]=1
		物件位置占位=新位置占位
	else:
		新位置占位[轨道位置]=1
		物件位置占位=新位置占位
	pass
func 音符生成(物件,位置):
	var 同排物件占位计数=0
	if $/root/根场景/主场景/无轨.visible==false:
		for 循环 in 物件位置占位.size():
			match 物件位置占位[循环]:
				1:
					if 位置==同排物件占位计数:
						get_node("/root/根场景/主场景/轨道/轨道根节点"+var_to_str(循环+1)+"/物件区").add_child(物件)
					同排物件占位计数+=1
				2:
					if 位置!=0:
						get_node("/root/根场景/主场景/轨道/轨道根节点"+var_to_str(循环+1)+"/物件区").add_child(物件)
	else:
		var 轨道位置=(randf()-0.5)*float(get_node("/root/根场景/根界面/游戏菜单/歌曲信息/歌曲信息/容器/轨道数量/滑块").value)*2-1
		物件.position=Vector3(轨道位置,物件.position[1],物件.position[2])
		get_node("/root/根场景/主场景/无轨/无轨根节点1/物件区").add_child(物件)
	pass

func 丢失生命值():
	生命值=生命值-10.0
	#游戏结束
	if 生命值<0.0:
		生命值=0.0
	pass
func 添加生命值(血量值):
	生命值=生命值+血量值
	#游戏结束
	if 生命值>100.0:
		生命值=100.0
	pass
